// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: protobuf/wallet.proto

package wallet

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ReturnCode int32

const (
	ReturnCode_ERROR   ReturnCode = 0
	ReturnCode_SUCCESS ReturnCode = 1
)

// Enum value maps for ReturnCode.
var (
	ReturnCode_name = map[int32]string{
		0: "ERROR",
		1: "SUCCESS",
	}
	ReturnCode_value = map[string]int32{
		"ERROR":   0,
		"SUCCESS": 1,
	}
)

func (x ReturnCode) Enum() *ReturnCode {
	p := new(ReturnCode)
	*p = x
	return p
}

func (x ReturnCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReturnCode) Descriptor() protoreflect.EnumDescriptor {
	return file_protobuf_wallet_proto_enumTypes[0].Descriptor()
}

func (ReturnCode) Type() protoreflect.EnumType {
	return &file_protobuf_wallet_proto_enumTypes[0]
}

func (x ReturnCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReturnCode.Descriptor instead.
func (ReturnCode) EnumDescriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{0}
}

type GetChainSignMethodRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Consumer      string                 `protobuf:"bytes,1,opt,name=consumer,proto3" json:"consumer,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	AssetType     string                 `protobuf:"bytes,4,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetChainSignMethodRequest) Reset() {
	*x = GetChainSignMethodRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetChainSignMethodRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetChainSignMethodRequest) ProtoMessage() {}

func (x *GetChainSignMethodRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetChainSignMethodRequest.ProtoReflect.Descriptor instead.
func (*GetChainSignMethodRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{0}
}

func (x *GetChainSignMethodRequest) GetConsumer() string {
	if x != nil {
		return x.Consumer
	}
	return ""
}

func (x *GetChainSignMethodRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *GetChainSignMethodRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *GetChainSignMethodRequest) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

type GetChainSignMethodResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=wallet.ReturnCode" json:"code,omitempty"`
	Msg           string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	SignMethod    string                 `protobuf:"bytes,3,opt,name=sign_method,json=signMethod,proto3" json:"sign_method,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetChainSignMethodResponse) Reset() {
	*x = GetChainSignMethodResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetChainSignMethodResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetChainSignMethodResponse) ProtoMessage() {}

func (x *GetChainSignMethodResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetChainSignMethodResponse.ProtoReflect.Descriptor instead.
func (*GetChainSignMethodResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{1}
}

func (x *GetChainSignMethodResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *GetChainSignMethodResponse) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

func (x *GetChainSignMethodResponse) GetSignMethod() string {
	if x != nil {
		return x.SignMethod
	}
	return ""
}

type GetChainSchemaRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Consumer      string                 `protobuf:"bytes,1,opt,name=consumer,proto3" json:"consumer,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	AssetType     string                 `protobuf:"bytes,4,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetChainSchemaRequest) Reset() {
	*x = GetChainSchemaRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetChainSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetChainSchemaRequest) ProtoMessage() {}

func (x *GetChainSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetChainSchemaRequest.ProtoReflect.Descriptor instead.
func (*GetChainSchemaRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{2}
}

func (x *GetChainSchemaRequest) GetConsumer() string {
	if x != nil {
		return x.Consumer
	}
	return ""
}

func (x *GetChainSchemaRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *GetChainSchemaRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *GetChainSchemaRequest) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

type GetChainSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Schema        string                 `protobuf:"bytes,3,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetChainSchemaResponse) Reset() {
	*x = GetChainSchemaResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetChainSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetChainSchemaResponse) ProtoMessage() {}

func (x *GetChainSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetChainSchemaResponse.ProtoReflect.Descriptor instead.
func (*GetChainSchemaResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{3}
}

func (x *GetChainSchemaResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *GetChainSchemaResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *GetChainSchemaResponse) GetSchema() string {
	if x != nil {
		return x.Schema
	}
	return ""
}

type ExportPublicKey struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PublicKey         string                 `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	CompressPublicKey string                 `protobuf:"bytes,2,opt,name=compress_public_key,json=compressPublicKey,proto3" json:"compress_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ExportPublicKey) Reset() {
	*x = ExportPublicKey{}
	mi := &file_protobuf_wallet_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportPublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportPublicKey) ProtoMessage() {}

func (x *ExportPublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExportPublicKey.ProtoReflect.Descriptor instead.
func (*ExportPublicKey) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{4}
}

func (x *ExportPublicKey) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *ExportPublicKey) GetCompressPublicKey() string {
	if x != nil {
		return x.CompressPublicKey
	}
	return ""
}

type CreateKeyPairAndExportPublicKeyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	KeyNum        uint64                 `protobuf:"varint,4,opt,name=key_num,json=keyNum,proto3" json:"key_num,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateKeyPairAndExportPublicKeyRequest) Reset() {
	*x = CreateKeyPairAndExportPublicKeyRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateKeyPairAndExportPublicKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateKeyPairAndExportPublicKeyRequest) ProtoMessage() {}

func (x *CreateKeyPairAndExportPublicKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateKeyPairAndExportPublicKeyRequest.ProtoReflect.Descriptor instead.
func (*CreateKeyPairAndExportPublicKeyRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{5}
}

func (x *CreateKeyPairAndExportPublicKeyRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *CreateKeyPairAndExportPublicKeyRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *CreateKeyPairAndExportPublicKeyRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *CreateKeyPairAndExportPublicKeyRequest) GetKeyNum() uint64 {
	if x != nil {
		return x.KeyNum
	}
	return 0
}

type CreateKeyPairAndExportPublicKeyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	PublicKeyList []*ExportPublicKey     `protobuf:"bytes,3,rep,name=public_key_list,json=publicKeyList,proto3" json:"public_key_list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateKeyPairAndExportPublicKeyResponse) Reset() {
	*x = CreateKeyPairAndExportPublicKeyResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateKeyPairAndExportPublicKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateKeyPairAndExportPublicKeyResponse) ProtoMessage() {}

func (x *CreateKeyPairAndExportPublicKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateKeyPairAndExportPublicKeyResponse.ProtoReflect.Descriptor instead.
func (*CreateKeyPairAndExportPublicKeyResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{6}
}

func (x *CreateKeyPairAndExportPublicKeyResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *CreateKeyPairAndExportPublicKeyResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *CreateKeyPairAndExportPublicKeyResponse) GetPublicKeyList() []*ExportPublicKey {
	if x != nil {
		return x.PublicKeyList
	}
	return nil
}

type ExportPublicKeyWithAddress struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PublicKey         string                 `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	CompressPublicKey string                 `protobuf:"bytes,2,opt,name=compress_public_key,json=compressPublicKey,proto3" json:"compress_public_key,omitempty"`
	Address           string                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ExportPublicKeyWithAddress) Reset() {
	*x = ExportPublicKeyWithAddress{}
	mi := &file_protobuf_wallet_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportPublicKeyWithAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportPublicKeyWithAddress) ProtoMessage() {}

func (x *ExportPublicKeyWithAddress) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExportPublicKeyWithAddress.ProtoReflect.Descriptor instead.
func (*ExportPublicKeyWithAddress) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{7}
}

func (x *ExportPublicKeyWithAddress) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *ExportPublicKeyWithAddress) GetCompressPublicKey() string {
	if x != nil {
		return x.CompressPublicKey
	}
	return ""
}

func (x *ExportPublicKeyWithAddress) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type CreateKeyPairsWithAddressesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	AddressFormat string                 `protobuf:"bytes,4,opt,name=address_format,json=addressFormat,proto3" json:"address_format,omitempty"`
	KeyNum        uint64                 `protobuf:"varint,5,opt,name=key_num,json=keyNum,proto3" json:"key_num,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateKeyPairsWithAddressesRequest) Reset() {
	*x = CreateKeyPairsWithAddressesRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateKeyPairsWithAddressesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateKeyPairsWithAddressesRequest) ProtoMessage() {}

func (x *CreateKeyPairsWithAddressesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateKeyPairsWithAddressesRequest.ProtoReflect.Descriptor instead.
func (*CreateKeyPairsWithAddressesRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{8}
}

func (x *CreateKeyPairsWithAddressesRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *CreateKeyPairsWithAddressesRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *CreateKeyPairsWithAddressesRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *CreateKeyPairsWithAddressesRequest) GetAddressFormat() string {
	if x != nil {
		return x.AddressFormat
	}
	return ""
}

func (x *CreateKeyPairsWithAddressesRequest) GetKeyNum() uint64 {
	if x != nil {
		return x.KeyNum
	}
	return 0
}

type CreateKeyPairsWithAddressesResponse struct {
	state              protoimpl.MessageState        `protogen:"open.v1"`
	Code               ReturnCode                    `protobuf:"varint,1,opt,name=code,proto3,enum=wallet.ReturnCode" json:"code,omitempty"`
	Message            string                        `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	PublicKeyAddresses []*ExportPublicKeyWithAddress `protobuf:"bytes,3,rep,name=public_key_addresses,json=publicKeyAddresses,proto3" json:"public_key_addresses,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CreateKeyPairsWithAddressesResponse) Reset() {
	*x = CreateKeyPairsWithAddressesResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateKeyPairsWithAddressesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateKeyPairsWithAddressesResponse) ProtoMessage() {}

func (x *CreateKeyPairsWithAddressesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateKeyPairsWithAddressesResponse.ProtoReflect.Descriptor instead.
func (*CreateKeyPairsWithAddressesResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{9}
}

func (x *CreateKeyPairsWithAddressesResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *CreateKeyPairsWithAddressesResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *CreateKeyPairsWithAddressesResponse) GetPublicKeyAddresses() []*ExportPublicKeyWithAddress {
	if x != nil {
		return x.PublicKeyAddresses
	}
	return nil
}

type BuildAndSignTransactionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	PublicKey     string                 `protobuf:"bytes,4,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	WalletKeyHash string                 `protobuf:"bytes,5,opt,name=wallet_key_hash,json=walletKeyHash,proto3" json:"wallet_key_hash,omitempty"`
	RiskKeyHash   string                 `protobuf:"bytes,6,opt,name=risk_key_hash,json=riskKeyHash,proto3" json:"risk_key_hash,omitempty"`
	TxBase64Body  string                 `protobuf:"bytes,7,opt,name=tx_base64_body,json=txBase64Body,proto3" json:"tx_base64_body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildAndSignTransactionRequest) Reset() {
	*x = BuildAndSignTransactionRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildAndSignTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildAndSignTransactionRequest) ProtoMessage() {}

func (x *BuildAndSignTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildAndSignTransactionRequest.ProtoReflect.Descriptor instead.
func (*BuildAndSignTransactionRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{10}
}

func (x *BuildAndSignTransactionRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetWalletKeyHash() string {
	if x != nil {
		return x.WalletKeyHash
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetRiskKeyHash() string {
	if x != nil {
		return x.RiskKeyHash
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetTxBase64Body() string {
	if x != nil {
		return x.TxBase64Body
	}
	return ""
}

type BuildAndSignTransactionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	TxMessageHash string                 `protobuf:"bytes,3,opt,name=tx_message_hash,json=txMessageHash,proto3" json:"tx_message_hash,omitempty"`
	TxHash        string                 `protobuf:"bytes,4,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	SignedTx      string                 `protobuf:"bytes,5,opt,name=signed_tx,json=signedTx,proto3" json:"signed_tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildAndSignTransactionResponse) Reset() {
	*x = BuildAndSignTransactionResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildAndSignTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildAndSignTransactionResponse) ProtoMessage() {}

func (x *BuildAndSignTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildAndSignTransactionResponse.ProtoReflect.Descriptor instead.
func (*BuildAndSignTransactionResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{11}
}

func (x *BuildAndSignTransactionResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *BuildAndSignTransactionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *BuildAndSignTransactionResponse) GetTxMessageHash() string {
	if x != nil {
		return x.TxMessageHash
	}
	return ""
}

func (x *BuildAndSignTransactionResponse) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *BuildAndSignTransactionResponse) GetSignedTx() string {
	if x != nil {
		return x.SignedTx
	}
	return ""
}

type TransactionMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PublicKey     string                 `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	WalletKeyHash string                 `protobuf:"bytes,2,opt,name=wallet_key_hash,json=walletKeyHash,proto3" json:"wallet_key_hash,omitempty"`
	RiskKeyHash   string                 `protobuf:"bytes,3,opt,name=risk_key_hash,json=riskKeyHash,proto3" json:"risk_key_hash,omitempty"`
	TxBase64Body  string                 `protobuf:"bytes,4,opt,name=tx_base64_body,json=txBase64Body,proto3" json:"tx_base64_body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransactionMessage) Reset() {
	*x = TransactionMessage{}
	mi := &file_protobuf_wallet_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransactionMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransactionMessage) ProtoMessage() {}

func (x *TransactionMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransactionMessage.ProtoReflect.Descriptor instead.
func (*TransactionMessage) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{12}
}

func (x *TransactionMessage) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *TransactionMessage) GetWalletKeyHash() string {
	if x != nil {
		return x.WalletKeyHash
	}
	return ""
}

func (x *TransactionMessage) GetRiskKeyHash() string {
	if x != nil {
		return x.RiskKeyHash
	}
	return ""
}

func (x *TransactionMessage) GetTxBase64Body() string {
	if x != nil {
		return x.TxBase64Body
	}
	return ""
}

type TransactionWithSign struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TxMessageHash string                 `protobuf:"bytes,1,opt,name=tx_message_hash,json=txMessageHash,proto3" json:"tx_message_hash,omitempty"`
	TxHash        string                 `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	SignedTx      string                 `protobuf:"bytes,3,opt,name=signed_tx,json=signedTx,proto3" json:"signed_tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransactionWithSign) Reset() {
	*x = TransactionWithSign{}
	mi := &file_protobuf_wallet_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransactionWithSign) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransactionWithSign) ProtoMessage() {}

func (x *TransactionWithSign) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransactionWithSign.ProtoReflect.Descriptor instead.
func (*TransactionWithSign) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{13}
}

func (x *TransactionWithSign) GetTxMessageHash() string {
	if x != nil {
		return x.TxMessageHash
	}
	return ""
}

func (x *TransactionWithSign) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *TransactionWithSign) GetSignedTx() string {
	if x != nil {
		return x.SignedTx
	}
	return ""
}

type BuildAndSignBatchTransactionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	TxMsg         []*TransactionMessage  `protobuf:"bytes,4,rep,name=tx_msg,json=txMsg,proto3" json:"tx_msg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildAndSignBatchTransactionRequest) Reset() {
	*x = BuildAndSignBatchTransactionRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildAndSignBatchTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildAndSignBatchTransactionRequest) ProtoMessage() {}

func (x *BuildAndSignBatchTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildAndSignBatchTransactionRequest.ProtoReflect.Descriptor instead.
func (*BuildAndSignBatchTransactionRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{14}
}

func (x *BuildAndSignBatchTransactionRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *BuildAndSignBatchTransactionRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *BuildAndSignBatchTransactionRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *BuildAndSignBatchTransactionRequest) GetTxMsg() []*TransactionMessage {
	if x != nil {
		return x.TxMsg
	}
	return nil
}

type BuildAndSignBatchTransactionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	TxWithSign    []*TransactionWithSign `protobuf:"bytes,3,rep,name=tx_with_sign,json=txWithSign,proto3" json:"tx_with_sign,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildAndSignBatchTransactionResponse) Reset() {
	*x = BuildAndSignBatchTransactionResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildAndSignBatchTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildAndSignBatchTransactionResponse) ProtoMessage() {}

func (x *BuildAndSignBatchTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildAndSignBatchTransactionResponse.ProtoReflect.Descriptor instead.
func (*BuildAndSignBatchTransactionResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{15}
}

func (x *BuildAndSignBatchTransactionResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *BuildAndSignBatchTransactionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *BuildAndSignBatchTransactionResponse) GetTxWithSign() []*TransactionWithSign {
	if x != nil {
		return x.TxWithSign
	}
	return nil
}

var File_protobuf_wallet_proto protoreflect.FileDescriptor

const file_protobuf_wallet_proto_rawDesc = "" +
	"\n" +
	"\x15protobuf/wallet.proto\x12\x06wallet\"\x8f\x01\n" +
	"\x19GetChainSignMethodRequest\x12\x1a\n" +
	"\bconsumer\x18\x01 \x01(\tR\bconsumer\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x04 \x01(\tR\tassetType\"w\n" +
	"\x1aGetChainSignMethodResponse\x12&\n" +
	"\x04code\x18\x01 \x01(\x0e2\x12.wallet.ReturnCodeR\x04code\x12\x10\n" +
	"\x03msg\x18\x02 \x01(\tR\x03msg\x12\x1f\n" +
	"\vsign_method\x18\x03 \x01(\tR\n" +
	"signMethod\"\x8b\x01\n" +
	"\x15getChainSchemaRequest\x12\x1a\n" +
	"\bconsumer\x18\x01 \x01(\tR\bconsumer\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x04 \x01(\tR\tassetType\"r\n" +
	"\x16getChainSchemaResponse\x12&\n" +
	"\x04code\x18\x01 \x01(\x0e2\x12.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x16\n" +
	"\x06schema\x18\x03 \x01(\tR\x06schema\"`\n" +
	"\x0fExportPublicKey\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\tR\tpublicKey\x12.\n" +
	"\x13compress_public_key\x18\x02 \x01(\tR\x11compressPublicKey\"\xa1\x01\n" +
	"&CreateKeyPairAndExportPublicKeyRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x17\n" +
	"\akey_num\x18\x04 \x01(\x04R\x06keyNum\"\xac\x01\n" +
	"'CreateKeyPairAndExportPublicKeyResponse\x12&\n" +
	"\x04code\x18\x01 \x01(\x0e2\x12.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12?\n" +
	"\x0fpublic_key_list\x18\x03 \x03(\v2\x17.wallet.ExportPublicKeyR\rpublicKeyList\"\x85\x01\n" +
	"\x1aExportPublicKeyWithAddress\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\tR\tpublicKey\x12.\n" +
	"\x13compress_public_key\x18\x02 \x01(\tR\x11compressPublicKey\x12\x18\n" +
	"\aaddress\x18\x03 \x01(\tR\aaddress\"\xc4\x01\n" +
	"\"CreateKeyPairsWithAddressesRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12%\n" +
	"\x0eaddress_format\x18\x04 \x01(\tR\raddressFormat\x12\x17\n" +
	"\akey_num\x18\x05 \x01(\x04R\x06keyNum\"\xbd\x01\n" +
	"#CreateKeyPairsWithAddressesResponse\x12&\n" +
	"\x04code\x18\x01 \x01(\x0e2\x12.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12T\n" +
	"\x14public_key_addresses\x18\x03 \x03(\v2\".wallet.ExportPublicKeyWithAddressR\x12publicKeyAddresses\"\x91\x02\n" +
	"\x1eBuildAndSignTransactionRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x1d\n" +
	"\n" +
	"public_key\x18\x04 \x01(\tR\tpublicKey\x12&\n" +
	"\x0fwallet_key_hash\x18\x05 \x01(\tR\rwalletKeyHash\x12\"\n" +
	"\rrisk_key_hash\x18\x06 \x01(\tR\vriskKeyHash\x12$\n" +
	"\x0etx_base64_body\x18\a \x01(\tR\ftxBase64Body\"\xc1\x01\n" +
	"\x1fBuildAndSignTransactionResponse\x12&\n" +
	"\x04code\x18\x01 \x01(\x0e2\x12.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12&\n" +
	"\x0ftx_message_hash\x18\x03 \x01(\tR\rtxMessageHash\x12\x17\n" +
	"\atx_hash\x18\x04 \x01(\tR\x06txHash\x12\x1b\n" +
	"\tsigned_tx\x18\x05 \x01(\tR\bsignedTx\"\xa5\x01\n" +
	"\x12TransactionMessage\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\tR\tpublicKey\x12&\n" +
	"\x0fwallet_key_hash\x18\x02 \x01(\tR\rwalletKeyHash\x12\"\n" +
	"\rrisk_key_hash\x18\x03 \x01(\tR\vriskKeyHash\x12$\n" +
	"\x0etx_base64_body\x18\x04 \x01(\tR\ftxBase64Body\"s\n" +
	"\x13TransactionWithSign\x12&\n" +
	"\x0ftx_message_hash\x18\x01 \x01(\tR\rtxMessageHash\x12\x17\n" +
	"\atx_hash\x18\x02 \x01(\tR\x06txHash\x12\x1b\n" +
	"\tsigned_tx\x18\x03 \x01(\tR\bsignedTx\"\xb8\x01\n" +
	"#BuildAndSignBatchTransactionRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x121\n" +
	"\x06tx_msg\x18\x04 \x03(\v2\x1a.wallet.TransactionMessageR\x05txMsg\"\xa7\x01\n" +
	"$BuildAndSignBatchTransactionResponse\x12&\n" +
	"\x04code\x18\x01 \x01(\x0e2\x12.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12=\n" +
	"\ftx_with_sign\x18\x03 \x03(\v2\x1b.wallet.TransactionWithSignR\n" +
	"txWithSign*$\n" +
	"\n" +
	"ReturnCode\x12\t\n" +
	"\x05ERROR\x10\x00\x12\v\n" +
	"\aSUCCESS\x10\x012\xa5\x05\n" +
	"\rWalletService\x12[\n" +
	"\x12getChainSignMethod\x12!.wallet.GetChainSignMethodRequest\x1a\".wallet.GetChainSignMethodResponse\x12O\n" +
	"\x0egetChainSchema\x12\x1d.wallet.getChainSchemaRequest\x1a\x1e.wallet.getChainSchemaResponse\x12\x84\x01\n" +
	"!createKeyPairsExportPublicKeyList\x12..wallet.CreateKeyPairAndExportPublicKeyRequest\x1a/.wallet.CreateKeyPairAndExportPublicKeyResponse\x12x\n" +
	"\x1bcreateKeyPairsWithAddresses\x12*.wallet.CreateKeyPairsWithAddressesRequest\x1a+.wallet.CreateKeyPairsWithAddressesResponse\"\x00\x12j\n" +
	"\x17buildAndSignTransaction\x12&.wallet.BuildAndSignTransactionRequest\x1a'.wallet.BuildAndSignTransactionResponse\x12y\n" +
	"\x1cbuildAndSignBatchTransaction\x12+.wallet.BuildAndSignBatchTransactionRequest\x1a,.wallet.BuildAndSignBatchTransactionResponseB\x13Z\x11./protobuf/walletb\x06proto3"

var (
	file_protobuf_wallet_proto_rawDescOnce sync.Once
	file_protobuf_wallet_proto_rawDescData []byte
)

func file_protobuf_wallet_proto_rawDescGZIP() []byte {
	file_protobuf_wallet_proto_rawDescOnce.Do(func() {
		file_protobuf_wallet_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_protobuf_wallet_proto_rawDesc), len(file_protobuf_wallet_proto_rawDesc)))
	})
	return file_protobuf_wallet_proto_rawDescData
}

var file_protobuf_wallet_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_protobuf_wallet_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_protobuf_wallet_proto_goTypes = []any{
	(ReturnCode)(0),                                 // 0: wallet.ReturnCode
	(*GetChainSignMethodRequest)(nil),               // 1: wallet.GetChainSignMethodRequest
	(*GetChainSignMethodResponse)(nil),              // 2: wallet.GetChainSignMethodResponse
	(*GetChainSchemaRequest)(nil),                   // 3: wallet.getChainSchemaRequest
	(*GetChainSchemaResponse)(nil),                  // 4: wallet.getChainSchemaResponse
	(*ExportPublicKey)(nil),                         // 5: wallet.ExportPublicKey
	(*CreateKeyPairAndExportPublicKeyRequest)(nil),  // 6: wallet.CreateKeyPairAndExportPublicKeyRequest
	(*CreateKeyPairAndExportPublicKeyResponse)(nil), // 7: wallet.CreateKeyPairAndExportPublicKeyResponse
	(*ExportPublicKeyWithAddress)(nil),              // 8: wallet.ExportPublicKeyWithAddress
	(*CreateKeyPairsWithAddressesRequest)(nil),      // 9: wallet.CreateKeyPairsWithAddressesRequest
	(*CreateKeyPairsWithAddressesResponse)(nil),     // 10: wallet.CreateKeyPairsWithAddressesResponse
	(*BuildAndSignTransactionRequest)(nil),          // 11: wallet.BuildAndSignTransactionRequest
	(*BuildAndSignTransactionResponse)(nil),         // 12: wallet.BuildAndSignTransactionResponse
	(*TransactionMessage)(nil),                      // 13: wallet.TransactionMessage
	(*TransactionWithSign)(nil),                     // 14: wallet.TransactionWithSign
	(*BuildAndSignBatchTransactionRequest)(nil),     // 15: wallet.BuildAndSignBatchTransactionRequest
	(*BuildAndSignBatchTransactionResponse)(nil),    // 16: wallet.BuildAndSignBatchTransactionResponse
}
var file_protobuf_wallet_proto_depIdxs = []int32{
	0,  // 0: wallet.GetChainSignMethodResponse.code:type_name -> wallet.ReturnCode
	0,  // 1: wallet.getChainSchemaResponse.code:type_name -> wallet.ReturnCode
	0,  // 2: wallet.CreateKeyPairAndExportPublicKeyResponse.code:type_name -> wallet.ReturnCode
	5,  // 3: wallet.CreateKeyPairAndExportPublicKeyResponse.public_key_list:type_name -> wallet.ExportPublicKey
	0,  // 4: wallet.CreateKeyPairsWithAddressesResponse.code:type_name -> wallet.ReturnCode
	8,  // 5: wallet.CreateKeyPairsWithAddressesResponse.public_key_addresses:type_name -> wallet.ExportPublicKeyWithAddress
	0,  // 6: wallet.BuildAndSignTransactionResponse.code:type_name -> wallet.ReturnCode
	13, // 7: wallet.BuildAndSignBatchTransactionRequest.tx_msg:type_name -> wallet.TransactionMessage
	0,  // 8: wallet.BuildAndSignBatchTransactionResponse.code:type_name -> wallet.ReturnCode
	14, // 9: wallet.BuildAndSignBatchTransactionResponse.tx_with_sign:type_name -> wallet.TransactionWithSign
	1,  // 10: wallet.WalletService.getChainSignMethod:input_type -> wallet.GetChainSignMethodRequest
	3,  // 11: wallet.WalletService.getChainSchema:input_type -> wallet.getChainSchemaRequest
	6,  // 12: wallet.WalletService.createKeyPairsExportPublicKeyList:input_type -> wallet.CreateKeyPairAndExportPublicKeyRequest
	9,  // 13: wallet.WalletService.createKeyPairsWithAddresses:input_type -> wallet.CreateKeyPairsWithAddressesRequest
	11, // 14: wallet.WalletService.buildAndSignTransaction:input_type -> wallet.BuildAndSignTransactionRequest
	15, // 15: wallet.WalletService.buildAndSignBatchTransaction:input_type -> wallet.BuildAndSignBatchTransactionRequest
	2,  // 16: wallet.WalletService.getChainSignMethod:output_type -> wallet.GetChainSignMethodResponse
	4,  // 17: wallet.WalletService.getChainSchema:output_type -> wallet.getChainSchemaResponse
	7,  // 18: wallet.WalletService.createKeyPairsExportPublicKeyList:output_type -> wallet.CreateKeyPairAndExportPublicKeyResponse
	10, // 19: wallet.WalletService.createKeyPairsWithAddresses:output_type -> wallet.CreateKeyPairsWithAddressesResponse
	12, // 20: wallet.WalletService.buildAndSignTransaction:output_type -> wallet.BuildAndSignTransactionResponse
	16, // 21: wallet.WalletService.buildAndSignBatchTransaction:output_type -> wallet.BuildAndSignBatchTransactionResponse
	16, // [16:22] is the sub-list for method output_type
	10, // [10:16] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_protobuf_wallet_proto_init() }
func file_protobuf_wallet_proto_init() {
	if File_protobuf_wallet_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_protobuf_wallet_proto_rawDesc), len(file_protobuf_wallet_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_protobuf_wallet_proto_goTypes,
		DependencyIndexes: file_protobuf_wallet_proto_depIdxs,
		EnumInfos:         file_protobuf_wallet_proto_enumTypes,
		MessageInfos:      file_protobuf_wallet_proto_msgTypes,
	}.Build()
	File_protobuf_wallet_proto = out.File
	file_protobuf_wallet_proto_goTypes = nil
	file_protobuf_wallet_proto_depIdxs = nil
}
